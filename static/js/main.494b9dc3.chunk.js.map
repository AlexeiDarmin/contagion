{"version":3,"sources":["models/index.ts","constants/index.ts","engine/index.ts","components/canvas.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["HealthStatus","ENGINE_OPTIONS","unitQty","unitSize","Node","x","y","size","vx","vy","status","Healthy","collisionCooldown","move","undoMove","this","genVector","distX","Math","random","distY","round","genRandomNumber","Engine","units","i","unit","createUnit","push","canvas","ctx","getContext","updateUnits","fillStyle","fillRect","lineWidth","length","beginPath","arc","PI","fill","stroke","nextUnits","unitA","pop","checkWallCollision","collided","unitB","collides","setTimeout","Models","laps","collisionFree","abs","min","max","floor","Canvas","props","canvasRef","engineInterval","state","engine","Constants","runAnimationFrame","current","update","React","createRef","setInterval","scale","clearInterval","id","ref","width","height","style","className","Component","App","key","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"4JAEKA,E,2ECOQC,EAAiB,CAC1BC,QAAS,IACTC,SAHqB,I,SDNpBH,O,qBAAAA,I,eAAAA,I,oBAAAA,M,KAOE,IAAMI,EAST,WAAYC,EAAWC,EAAWC,GAAe,IAAD,gCARhDF,EAAI,EAQ4C,KAPhDC,EAAI,EAO4C,KANhDE,GAAK,EAM2C,KALhDC,GAAK,EAK2C,KAJhDF,KAAO,EAIyC,KAHhDG,OAASV,EAAaW,QAG0B,KAFhDC,mBAAoB,EAE4B,KAUhDC,KAAO,WACH,EAAKR,GAAK,EAAKG,GACf,EAAKF,GAAK,EAAKG,IAZ6B,KAehDK,SAAW,WACP,EAAKT,GAAK,EAAKG,GACf,EAAKF,GAAK,EAAKG,IAhBfM,KAAKV,EAAIA,EACTU,KAAKT,EAAIA,EACTS,KAAKR,KAAOA,EAHgC,MAKzBS,IAAXR,EALoC,EAKpCA,GAAIC,EALgC,EAKhCA,GACZM,KAAKP,GAAKA,EACVO,KAAKN,GAAKA,GAuBLO,EAAY,WACrB,IAAMC,EAAQC,KAAKC,SACbC,EAAQ,EAAIH,EAIlB,MAAO,CACHT,GAAIS,GAJgD,GAArCC,KAAKG,MAAMC,EAAgB,EAAG,IAAW,GAAK,GAK7Db,GAAIW,GAJgD,GAArCF,KAAKG,MAAMC,EAAgB,EAAG,IAAW,GAAK,KE5CxDC,EAAb,WAGI,cAAmD,IAArCrB,EAAoC,EAApCA,QAASC,EAA2B,EAA3BA,SAA2B,yBAFlDqB,WAEkD,EAC9CT,KAAKS,MAAQ,GAEb,IAAK,IAAIC,EAAI,EAAGA,EAAIvB,EAASuB,IAAK,CAC9B,IAAMC,EAAOC,EAAWZ,KAAKS,MAAOrB,GAEpCY,KAAKS,MAAMI,KAAKF,IAT5B,mDAaWG,GACH,IAAMC,EAAMD,EAAOE,WAAW,MAE9B,IAAKD,EACD,KAAM,sCAGVf,KAAKS,MAAQQ,EAAYjB,KAAKS,OAE9BM,EAAIG,UAAY,UAChBH,EAAII,SAAS,EAAG,ED3BG,IACC,KC4BpBJ,EAAIK,UAAY,GAChB,IAAK,IAAIV,EAAI,EAAGA,EAAIV,KAAKS,MAAMY,OAAQX,IAAK,CAAC,IAAD,EACjBV,KAAKS,MAAMC,GAA1BpB,EADgC,EAChCA,EAAGC,EAD6B,EAC7BA,EAAGC,EAD0B,EAC1BA,KACduB,EAAIG,UAAY,QAChBH,EAAIO,YACJP,EAAIQ,IAAKjC,EAAIE,EAAO,EAAKD,EAAIC,EAAO,EAAIA,EAAM,EAAG,EAAIW,KAAKqB,IAC1DT,EAAIU,OACJV,EAAIW,cAhChB,KA2CaT,EAAc,SAACR,GAGxB,IAFA,IAAMkB,EAAY,GAD+B,aAI7C,IAAMC,EAAQnB,EAAMoB,MAEpB,IAAKD,EACD,iBAGJE,EAAmBF,GACnB,IAAIG,GAAW,EAEf,GADAH,EAAM9B,OACF8B,EAAM/B,kBAEN,OADA8B,EAAUd,KAAKe,GACf,WAfyC,eAiBpClB,GACL,IAAMsB,EAAQvB,EAAMC,GACpB,OAAKsB,EAGDA,EAAMnC,kBACN,YAEJmC,EAAMlC,OAEFmC,EAASL,EAAOI,IAEhBJ,EAAMnC,KAAO,EACbmC,EAAMlC,KAAO,EACbsC,EAAMvC,KAAO,EACbuC,EAAMtC,KAAO,EACbiC,EAAUd,KAAKe,GACfD,EAAUd,KAAKmB,GACfD,GAAW,EAGXH,EAAM/B,mBAAoB,EAC1BmC,EAAMnC,mBAAoB,EAC1BqC,YAAW,kBAAMN,EAAM/B,mBAAoB,IAAO,KAClDqC,YAAW,kBAAMF,EAAMnC,mBAAoB,IAAO,KAElDiC,EAAmBE,UACZvB,EAAMC,GACb,cAEAsB,EAAMjC,YA3BN,YApBqC,EAiB7C,IAAK,IAAIW,EAAI,EAAGA,EAAID,EAAMY,OAAQX,IAAI,UAA7BA,IAA6B,eAM9B,SAN8B,YA4B9B,SAMHqB,GACDJ,EAAUd,KAAKe,IAjDhBnB,EAAMY,OAAS,GAAG,IAqDzB,OAAOM,GAQEG,EAAqB,SAACnB,GAC3BA,EAAKrB,EAAI,IACTqB,EAAKlB,KAAO,GAEZkB,EAAKrB,EAAIqB,EAAKnB,MDnHK,MCoHnBmB,EAAKlB,KAAO,GAEZkB,EAAKpB,EAAI,IACToB,EAAKjB,KAAO,GAEZiB,EAAKpB,EAAIoB,EAAKnB,MDxHM,MCyHpBmB,EAAKjB,KAAO,IAoBPkB,EAAa,SAACH,EAAsBrB,GAO7C,IANA,IAAMuB,EAAO,IAAIwB,EAAY,EAAG,EAAG/C,GAE/BE,EAAIiB,EAAgB,EDjJD,ICiJ4BnB,GAC/CG,EAAIgB,EAAgB,EDjJA,ICiJ4BnB,GAEhDgD,EAAO,IACE,CACTzB,EAAKrB,EAAIA,EACTqB,EAAKpB,EAAIA,EAGT,IADA,IAAI8C,GAAgB,EACX3B,EAAI,EAAGA,EAAID,EAAMY,OAAQX,IAAK,CACnC,IAAMsB,EAAQvB,EAAMC,GAEpB,GAAIuB,EAAStB,EAAMqB,GAAQ,CACvBK,GAAgB,EAChB,OAIR,GAAIA,EACA,OAAO1B,EAKX,IADArB,GAAKF,GACGA,GDzKW,MC0KfE,EAAI,GACJC,GAAKH,ID1KW,KC2KiB,CAC7B,GAAY,GAARgD,EACA,KAAM,6EAEV7C,EAAI,EACJ6C,GAAQ,KAYXH,EAAW,SAACL,EAAoBI,GACzC,IAAKJ,IAAUI,EACX,KAAM,gEAGV,IAAMxC,EAAoB,EAAboC,EAAMpC,KAAW,EAE9B,OAAOW,KAAKmC,IAAIV,EAAMtC,EAAI0C,EAAM1C,GAAKa,KAAKmC,IAAIV,EAAMrC,EAAIyC,EAAMzC,IAAMC,GA0C3De,EAAkB,SAACgC,EAAaC,GACzC,OAAOrC,KAAKsC,MAAMtC,KAAKC,UAAYoC,EAAMD,EAAM,IAAMA,GC1L1CG,E,YA5CX,WAAYC,GAAa,IAAD,8BACpB,4CAAMA,KARVC,eAOwB,IANxBC,oBAMwB,IAJxBC,MAAQ,CACJC,OAAQ,IAAIvC,EAAcwC,IAGN,EAiBxBC,kBAAoB,WAChB,IAAMnC,EAAS,EAAK8B,UAAUM,QACzBpC,GAKL,EAAKgC,MAAMC,OAAOI,OAAOrC,IArBzB,EAAK8B,UAAYQ,IAAMC,YAHH,E,iFAMH,IAAD,IAChBrD,KAAK6C,eAAiBS,YAAYtD,KAAKiD,kBAAmB,IAC1D,UAAAjD,KAAK4C,UAAUM,eAAf,mBAAwBlC,WAAW,aAAnC,SAA0CuC,MFfvB,O,6CEmBfvD,KAAK6C,gBACLW,cAAcxD,KAAK6C,kB,+BAevB,OAAO,4BACHY,GAAG,aACHC,IAAK1D,KAAK4C,UACVe,MAAK,UAAKX,IAAL,MACLY,OAAM,UAAKZ,IAAL,MACNa,MAAO,CACHF,MAAM,GAAD,OF3CM,IE2CN,MACLC,OAAO,GAAD,OF3CM,IE2CN,OAEVE,UAAU,oB,GA7CDV,IAAMW,W,MCiBZC,MAhBf,WACE,OACE,yBAAKF,UAAU,OACb,4BAAQA,UAAU,cAAlB,YAEE,yBAAKA,UAAU,iBAAf,2EAIF,6BACE,kBAAC,EAAD,CAAUG,IAAI,YCJFC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SDqI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.494b9dc3.chunk.js","sourcesContent":["import { genRandomNumber } from \"../engine\"\n\nenum HealthStatus {\n    Healthy = 1,\n    Sick,\n    Immune\n}\n\n\nexport class Node {\n    x = 0\n    y = 0\n    vx = 0\n    vy = 0\n    size = 5\n    status = HealthStatus.Healthy\n    collisionCooldown = false\n\n    constructor(x: number, y: number, size: number) {\n        this.x = x\n        this.y = y\n        this.size = size\n\n        const { vx, vy } = genVector()\n        this.vx = vx\n        this.vy = vy \n    }\n\n    move = () => {\n        this.x += this.vx\n        this.y += this.vy\n    }\n\n    undoMove = () => {\n        this.x -= this.vx\n        this.y -= this.vy\n    }\n}\n\nexport interface Vector {\n    vx: number\n    vy: number\n}\n\n/**\n* Generates a normalized vector where the sum of the x and y velocities' equals to one.\n* @returns a vector\n*/\nexport const genVector = () => {\n    const distX = Math.random()\n    const distY = 1 - distX\n    const directionX = Math.round(genRandomNumber(0, 1)) == 1 ? 1 : -1\n    const directionY = Math.round(genRandomNumber(0, 1)) == 1 ? 1 : -1\n\n    return {\n        vx: distX * directionX,\n        vy: distY * directionY\n    }\n}\n\n/**\n* Returns a new vector with the vx, and vy signs inverted.\n* @param a vector\n* @returns a vector\n*/\nexport const invertVector = (vector: Vector) => {\n    return {\n        vx: vector.vx * -1,\n        vy: vector.vy * -1\n    }\n}","import * as Constants from '.'\n\nexport const FPS = 40\n\nexport const FIELD_WIDTH = 500\nexport const FIELD_HEIGHT = 250\nexport const FIELD_SCALE = 4\n\nexport const UNIT_SIZE = 5\nexport const ENGINE_OPTIONS = {\n    unitQty: 100,\n    unitSize: Constants.UNIT_SIZE\n}","import * as Models from '../models'\nimport * as Constants from '../constants'\n\nexport interface EngineOptions {\n    unitQty: number\n    unitSize: number\n}\n\nexport class Engine {\n    units: Models.Node[]\n\n    constructor({ unitQty, unitSize }: EngineOptions) {\n        this.units = []\n\n        for (let i = 0; i < unitQty; i++) {\n            const unit = createUnit(this.units, unitSize)\n\n            this.units.push(unit)\n        }\n    }\n\n    update(canvas: HTMLCanvasElement) {\n        const ctx = canvas.getContext('2d') as CanvasRenderingContext2D\n\n        if (!ctx) {\n            throw 'expected canvas ctx to exist by now'\n        }\n\n        this.units = updateUnits(this.units)\n\n        ctx.fillStyle = \"#fff5f5\";\n        ctx.fillRect(0, 0, Constants.FIELD_WIDTH, Constants.FIELD_HEIGHT);\n\n        ctx.lineWidth = 0.5;\n        for (let i = 0; i < this.units.length; i++) {\n            const { x, y, size } = this.units[i]\n            ctx.fillStyle = \"green\";\n            ctx.beginPath();\n            ctx.arc((x + size / 2), (y + size / 2), size, 0, 2 * Math.PI);\n            ctx.fill();\n            ctx.stroke();\n        }\n    }\n}\n\n/**\n* Moves each unit and updates their direction vectors based on collisions.\n* @param unit a unit\n* @param units units\n* @returns an instance of a unit\n*/\nexport const updateUnits = (units: Models.Node[]) => {\n    const nextUnits = []\n\n    while (units.length > 0) {\n        const unitA = units.pop()\n\n        if (!unitA) {\n            continue\n        }\n        // Multiple seperate collision detectors may cause issues...\n        checkWallCollision(unitA)\n        let collided = false\n        unitA.move()\n        if (unitA.collisionCooldown) {\n            nextUnits.push(unitA)\n            continue\n        }\n        for (let i = 0; i < units.length; i++){\n            const unitB = units[i]\n            if (!unitB){\n                continue\n            }\n            if (unitB.collisionCooldown) {\n                continue\n            }\n            unitB.move()\n\n            if (collides(unitA, unitB)) {\n                // applyCollisionRedirect(unitA, unitB)\n                unitA.vx *= -1\n                unitA.vy *= -1\n                unitB.vx *= -1\n                unitB.vy *= -1\n                nextUnits.push(unitA)\n                nextUnits.push(unitB)\n                collided = true\n\n                // Generalize to a function\n                unitA.collisionCooldown = true\n                unitB.collisionCooldown = true\n                setTimeout(() => unitA.collisionCooldown = false, 100)\n                setTimeout(() => unitB.collisionCooldown = false, 100)\n\n                checkWallCollision(unitB)\n                delete units[i]\n                break\n            } else {\n                unitB.undoMove()\n            }\n        }\n\n        if (!collided) {\n            nextUnits.push(unitA)\n        }\n    }\n    \n    return nextUnits\n}\n\n/**\n* Modifies a unit's direction vector if it has collided with a wall\n* @param unit a unit\n* @returns void\n*/\nexport const checkWallCollision = (unit: Models.Node) => {\n    if (unit.x < 0){\n        unit.vx *= -1\n    }\n    if (unit.x + unit.size >= Constants.FIELD_WIDTH) {\n        unit.vx *= -1\n    }\n    if (unit.y < 0) {\n        unit.vy *= -1\n    }\n    if (unit.y + unit.size >= Constants.FIELD_HEIGHT) {\n        unit.vy *= -1\n    }\n}\n\n/**\n* Updates the X, Y position of the unit with respect to its movement vector.\n* @param unit a unit\n* @returns an instance of a unit\n*/\nexport const moveUnit = (unit: Models.Node) => {\n    unit.x += unit.vx\n    unit.y += unit.vy\n}\n\n/**\n* Creates a new unit with whose (x, y) position does not collide with any other unit from units.\n* @param units list of units\n* @param unitSize the size of the unit to be created\n* @returns an instance of a unit\n*/\nexport const createUnit = (units: Models.Node[], unitSize: number): Models.Node => {\n    const unit = new Models.Node(0, 0, unitSize)\n\n    let x = genRandomNumber(0, Constants.FIELD_WIDTH - unitSize)\n    let y = genRandomNumber(0, Constants.FIELD_HEIGHT - unitSize)\n\n    let laps = 0\n    while (true) {\n        unit.x = x\n        unit.y = y\n\n        let collisionFree = true\n        for (let i = 0; i < units.length; i++) {\n            const unitB = units[i]\n\n            if (collides(unit, unitB)) {\n                collisionFree = false\n                break\n            }\n        }\n\n        if (collisionFree) {\n            return unit\n        }\n\n        // TODO: Find a cleaner way to shift colliding units.\n        x += unitSize\n        if (x + unitSize >= Constants.FIELD_WIDTH) {\n            x = 0\n            y += unitSize\n            if (y >= Constants.FIELD_HEIGHT) {\n                if (laps == 1) {\n                    throw 'after scanning the entire field, no position available to insert next unit'\n                }\n                y = 0\n                laps += 1\n            }\n        }\n    }\n}\n\n/**\n* Checks if two units collide. Returns true if they do, false otherwise.\n* @param unitA a unit\n* @param unitB a unit\n* @returns an instance of a unit\n*/\nexport const collides = (unitA: Models.Node, unitB: Models.Node) => {\n    if (!unitA || !unitB) {\n        throw 'collides() expects two units to compare, received one or less'\n    }\n\n    const size = unitA.size * 2 + 1\n\n    return Math.abs(unitA.x - unitB.x) + Math.abs(unitA.y - unitB.y) <= size\n}\n\n/**\n* Updates the motion vector for two units that have collided\n* @param unitA a unit\n* @param unitB a unit\n* @returns void\n*/\nexport const applyCollisionRedirect = (unitA: Models.Node, unitB: Models.Node) => {\n    if (!unitA || !unitB) {\n        throw 'applyCollisionRedirect() expects two units to compare, received one or less'\n    }\n\n    const newAVector = {\n        vx: unitA.vx + unitB.vx / 4,\n        vy: unitA.vy + unitB.vy / 4\n    }\n    const newBVector = {\n        vx: unitB.vx + unitA.vx / 4,\n        vy: unitB.vy + unitA.vy / 4\n    }\n\n    // normalize vectors to sum to one\n    const s1 = newAVector.vx + newAVector.vy\n    const s2 = newBVector.vx + newBVector.vy\n\n    unitA.vx = newAVector.vx / s1\n    unitA.vy = newAVector.vy / s1\n    unitB.vx = newBVector.vx / s2\n    unitB.vy = newBVector.vy / s2\n\n}\n\n\n\n/**\n* Generates a random number within the provided bounds of min and max.\n* @param min the inclusive lower bound\n* @param max the exclusive upper bound\n* @returns models.Node\n*/\nexport const genRandomNumber = (min: number, max: number) => {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n\n/**\n * Problems to solve:\n    (done) 1 - generate sudo-random starting positions for objects effectively\n    (ish)  2 - make it impossible for simulation to crash (limit object creation)\n    (done) 3 - find collisions efficiently\n    (wip)  4 - calculate new travel vectors\n    (done) 5 - redirect on collision with map boundaries\n * **/\n","import React from 'react';\n\nimport * as Constants from '../constants'\nimport * as Engine from '../engine'\n\nclass Canvas extends React.Component {\n    canvasRef: React.RefObject<HTMLCanvasElement>\n    engineInterval?: ReturnType<typeof setInterval>\n\n    state = {\n        engine: new Engine.Engine(Constants.ENGINE_OPTIONS)\n    }\n\n    constructor(props: any) {\n        super(props)\n\n        this.canvasRef = React.createRef<HTMLCanvasElement>();\n    }\n\n    componentDidMount() {\n        this.engineInterval = setInterval(this.runAnimationFrame, 1000 / Constants.FPS);\n        this.canvasRef.current?.getContext('2d')?.scale(Constants.FIELD_SCALE, Constants.FIELD_SCALE)\n    }\n\n    componentWillUnmount() {\n        if (this.engineInterval) {\n            clearInterval(this.engineInterval)\n        }\n    }\n\n    runAnimationFrame = () => {\n        const canvas = this.canvasRef.current\n        if (!canvas) {\n            return\n            throw 'canvas should exist before executing runAnimationFrame()'\n        }\n\n        this.state.engine.update(canvas)\n    }\n\n    render() {\n        return <canvas\n            id=\"mainCanvas\"\n            ref={this.canvasRef}\n            width={`${Constants.FIELD_WIDTH * Constants.FIELD_SCALE}px`}\n            height={`${Constants.FIELD_HEIGHT * Constants.FIELD_SCALE}px`}\n            style={{\n                width: `${Constants.FIELD_WIDTH}px`,\n                height: `${Constants.FIELD_HEIGHT}px`,\n            }}\n            className=\"main-canvas\">\n\n        </canvas>\n    }\n\n}\n\nexport default Canvas;\n","import React from 'react';\n\nimport logo from './logo.svg';\nimport COCanvas from './components/canvas'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        Contagion\n        <div className=\"App-subheader\">\n          A simulation of the effects our actions have on the spread of a virus.\n        </div>\n      </header>\n      <div>\n        <COCanvas key='main' />\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}